pkg install -y python && python3 - <<'PYCODE'
#!/usr/bin/env python3
import os, stat, subprocess, sys
from pathlib import Path
print("\n=== [Termux Android Build Environment Setup + Auto Builder] ===\n")
shell_script = """#!/data/data/com.termux/files/usr/bin/bash
set -euo pipefail
echo
echo "== Step 1: Updating base system =="
pkg update -y && pkg upgrade -y
echo
echo "== Step 2: Installing build essentials =="
pkg install -y git wget unzip openjdk-17 gradle clang make python
echo
echo "== Step 3: Creating workspace =="
WORKDIR="$HOME/termux-build"
mkdir -p "$WORKDIR" && cd "$WORKDIR"
if [ ! -d termux-app ]; then
  echo
  echo "== Step 4: Cloning official Termux source =="
  git clone https://github.com/termux/termux-app.git
else
  echo "termux-app already exists — skipping clone."
fi
cd termux-app
echo
echo "== Step 5: Checking Gradle wrapper =="
if [ -f ./gradlew ]; then
  chmod +x ./gradlew
  echo "Using local Gradle wrapper"
else
  echo "No gradlew found, will use system Gradle"
fi
echo
echo "== Step 6: Building debug APK =="
(./gradlew assembleDebug 2>/dev/null || gradle assembleDebug) || echo "Build failed — check dependencies"
echo
echo "== Step 7: Summary =="
echo "APK (if built):"
find app/build/outputs/apk -type f -name "*.apk" || echo "No APK found"
echo
echo "== Build complete. =="
"""
installer_path = Path("termux_auto_build.sh")
installer_path.write_text(shell_script)
installer_path.chmod(installer_path.stat().st_mode | stat.S_IEXEC)
print(f"[*] Installer script written to: {installer_path.resolve()}")
print("[*] Starting setup and build...\n")
subprocess.run(["bash", str(installer_path)], check=False)
#!/usr/bin/env python3
"""
grrfp_rahulai_integration.py
Single-file prototype integrating GRRFP + Rahul.ai (simulated).
Run: python3 grrfp_rahulai_integration.py
"""
import asyncio
import random
import time
from dataclasses import dataclass, field
from typing import Dict, Any, List, Callable
import math
import uuid
# ---------------------------
# Utilities
# ---------------------------
def now_ts():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
def clamp(v, a, b):
    return max(a, min(b, v))
# ---------------------------
# RKC Logger (Resonant Knowledge Codex)
# ---------------------------
class RKCLogger:
    def __init__(self):
        self.entries: List[Dict[str, Any]] = []
    def log(self, source: str, level: str, payload: Dict[str, Any]):
        entry = {
            "id": str(uuid.uuid4()),
            "ts": now_ts(),
            "source": source,
            "level": level,
            "payload": payload
        }
        self.entries.append(entry)
        # compact print for demo
        print(f"[RKC] {entry['ts']} | {source} | {level} | {payload}")
    def dump(self):
        return self.entries
# ---------------------------
# UCG - Universal Circulation Governor (light)
# ---------------------------
class UCG:
    def __init__(self, logger: RKCLogger):
        self.logger = logger
        self.global_load = 0.0  # 0..1
        self.max_allowed_load = 0.9
    def evaluate(self, system_metrics: Dict[str, float]) -> Dict[str, Any]:
        # very small policy: compute load and yield controls
        self.global_load = clamp(system_metrics.get("energy_usage", 0.0), 0.0, 1.0)
        action = "ALLOW" if self.global_load < self.max_allowed_load else "THROTTLE"
        self.logger.log("UCG", "INFO", {"global_load": self.global_load, "action": action})
        return {"action": action, "global_load": self.global_load}
# ---------------------------
# EEG Simulator (mock sensor)
# ---------------------------
class EEGSimulator:
    """
    Simulates EEG-derived features:
      - attention (0..1)
      - relaxation (0..1)
      - intent_power (0..1) : strength of an expressed intent
      - micro_vibration (0..1) : body microvibe
    """
    def __init__(self, seed=None):
        self.rnd = random.Random(seed)
    async def stream(self, callback: Callable[[Dict[str, float]], None], interval=0.5):
        while True:
            sample = {
                "attention": clamp(self.rnd.gauss(0.5, 0.18), 0.0, 1.0),
                "relaxation": clamp(self.rnd.gauss(0.5, 0.18), 0.0, 1.0),
                "intent_power": clamp(abs(self.rnd.gauss(0.2, 0.2)), 0.0, 1.0),
                "micro_vibration": clamp(abs(self.rnd.gauss(0.05, 0.05)), 0.0, 1.0)
            }
            callback(sample)
            await asyncio.sleep(interval)
# ---------------------------
# NRPI Bridge (Neuro-Resonant Postural Interface) - preprocess
# ---------------------------
class NRPI:
    def __init__(self, logger: RKCLogger):
        self.logger = logger
        # calibration map - scale and offsets
        self.calibration = {"attention": (1.0, 0.0), "relaxation": (1.0, 0.0),
                            "intent_power": (1.0, 0.0), "micro_vibration": (1.0, 0.0)}
    def calibrate(self, baseline: Dict[str, float]):
        # simple baseline store
        for k, v in baseline.items():
            self.calibration[k] = (1.0, -v)  # subtract baseline
        self.logger.log("NRPI", "DEBUG", {"calibration": self.calibration})
    def preprocess(self, sample: Dict[str, float]) -> Dict[str, float]:
        # apply simple linear calibration + feature extraction
        out = {}
        for k, v in sample.items():
            scale, offset = self.calibration.get(k, (1.0, 0.0))
            out[k] = clamp(v * scale + offset, 0.0, 1.0)
        # derive an "resonant_impulse" metric
        out["resonant_impulse"] = clamp((out["attention"] * 0.5 + out["intent_power"] * 0.5) * (1 - out["micro_vibration"]), 0.0, 1.0)
        self.logger.log("NRPI", "TRACE", {"raw": sample, "pre": out})
        return out
# ---------------------------
# Neural Decoder (very small rule-based / ML placeholder)
# ---------------------------
class NeuralDecoder:
    """
    Maps preprocessed features to intents and token candidates.
    In real system this would be a trained model (LSTM/Transformer).
    Here we implement simple heuristic scoring and classification.
    """
    def __init__(self, logger: RKCLogger):
        self.logger = logger
        # vocabulary of candidate intents (minimal)
        self.vocab = {
            "greeting": ["hello", "hi", "hey"],
            "status": ["i am fine", "i am tired", "i am focused"],
            "action:lights_on": ["turn on lights", "lights on"],
            "action:lights_off": ["turn off lights", "lights off"],
            "silence": [""]
        }
    def decode(self, features: Dict[str, float]) -> Dict[str, Any]:
        ri = features.get("resonant_impulse", 0.0)
        attention = features.get("attention", 0.0)
        relaxation = features.get("relaxation", 0.0)
        intent_power = features.get("intent_power", 0.0)
        # scoring heuristic
        scores = {}
        scores["greeting"] = 0.3 * attention + 0.7 * intent_power * (1 - relaxation)
        scores["status"] = 0.2 * relaxation + 0.6 * attention
        scores["action:lights_on"] = 0.9 * ri if ri > 0.6 else 0.1 * ri
        scores["action:lights_off"] = 0.9 * ri * 0.5 if ri > 0.7 else 0.05 * ri
        scores["silence"] = 1.0 - clamp(attention + intent_power * 0.5, 0.0, 1.0)
        # pick best
        best = max(scores.items(), key=lambda kv: kv[1])
        intent, score = best
        self.logger.log("NeuralDecoder", "INFO", {"features": features, "scores": scores, "chosen": (intent, score)})
        # map to candidate text
        candidate_text = random.choice(self.vocab.get(intent, [""]))
        confidence = clamp(score, 0.0, 1.0)
        return {"intent": intent, "text_candidate": candidate_text, "confidence": confidence}
# ---------------------------
# Rahul.ai Cognitive Resonance Layer
# ---------------------------
@dataclass
class MemoryRecord:
    ts: str
    features: Dict[str, float]
    intent: str
    text: str
    confidence: float
class RahulAI:
    """
    Lightweight Rahul.ai prototype:
     - maps decoder candidate to enriched text using memory and context
     - maintains short-term memory and resonance mapping
    """
    def __init__(self, logger: RKCLogger):
        self.logger = logger
        self.short_memory: List[MemoryRecord] = []
        self.max_mem = 32
    def interpret(self, decoded: Dict[str, Any], features: Dict[str, float]) -> Dict[str, Any]:
        intent = decoded["intent"]
        candidate = decoded["text_candidate"]
        conf = decoded["confidence"]
        # enrich: incorporate memory resonance (simple)
        recent_context = self._context_summary()
        if intent.startswith("action:") and conf > 0.6:
            # create command-style text
            text = candidate
        elif intent == "greeting" and conf > 0.4:
            text = candidate + ", friend."
        elif intent == "status":
            # generate status text based on relaxation/attention
            text = "I sense you are " + ("calm" if features["relaxation"] > 0.6 else "alert")
        else:
            text = ""  # silence or unsure
        # store memory
        record = MemoryRecord(ts=now_ts(), features=features.copy(), intent=intent, text=text, confidence=conf)
        self.short_memory.append(record)
        if len(self.short_memory) > self.max_mem:
            self.short_memory.pop(0)
        self.logger.log("RahulAI", "DEBUG", {"intent": intent, "text": text, "conf": conf, "context": recent_context})
        return {"intent": intent, "text": text, "confidence": conf}
    def _context_summary(self):
        if not self.short_memory:
            return {"recent": None}
        last = self.short_memory[-1]
        return {"recent_intent": last.intent, "recent_text": last.text, "recent_conf": last.confidence}
# ---------------------------
# SpandanOS - Orchestrator
# ---------------------------
class SpandanOS:
    """
    Receives Rahul.ai interpretation and makes system-level decisions,
    e.g., execute action, notify devices, or require confirmation.
    """
    def __init__(self, logger: RKCLogger, ucg: UCG):
        self.logger = logger
        self.ucg = ucg
        # device state mock
        self.devices = {"lights": False}
    def decide(self, rahul_out: Dict[str, Any], features: Dict[str, float]) -> Dict[str, Any]:
        intent = rahul_out["intent"]
        text = rahul_out["text"]
        conf = rahul_out["confidence"]
        system_metrics = {"energy_usage": features.get("resonant_impulse", 0.0) * 0.5}
        ucg_decision = self.ucg.evaluate(system_metrics)
        action_taken = None
        if intent == "action:lights_on" and conf > 0.6 and ucg_decision["action"] == "ALLOW":
            self.devices["lights"] = True
            action_taken = "lights_on"
        elif intent == "action:lights_off" and conf > 0.6 and ucg_decision["action"] == "ALLOW":
            self.devices["lights"] = False
            action_taken = "lights_off"
        else:
            # not an action or not confident
            action_taken = None
        self.logger.log("SpandanOS", "INFO", {"intent": intent, "text": text, "conf": conf, "ucg": ucg_decision, "action_taken": action_taken})
        return {"action_taken": action_taken, "device_state": self.devices.copy(), "output_text": text}
# ---------------------------
# Main Integration Loop
# ---------------------------
async def main_loop(runtime_seconds=20):
    logger = RKCLogger()
    ucg = UCG(logger)
    nrpi = NRPI(logger)
    decoder = NeuralDecoder(logger)
    rahul = RahulAI(logger)
    spandan = SpandanOS(logger, ucg)
    eeg = EEGSimulator(seed=42)
    # simple calibration pass: average of a few samples
    baseline_samples = []
    def collect_baseline(s):
        baseline_samples.append(s)
    # collect 6 quick baseline samples synchronously (simulate)
    for _ in range(6):
        s = {"attention": random.uniform(0.3, 0.6), "relaxation": random.uniform(0.3, 0.6),
             "intent_power": random.uniform(0.0, 0.2), "micro_vibration": random.uniform(0.0, 0.08)}
        baseline_samples.append(s)
    # compute baseline mean
    baseline_mean = {}
    for k in baseline_samples[0].keys():
        baseline_mean[k] = sum(s[k] for s in baseline_samples) / len(baseline_samples)
    nrpi.calibrate(baseline_mean)
    logger.log("System", "INFO", {"calibration_mean": baseline_mean})
    # callback pipeline
    async def on_sample_loop(sample):
        features = nrpi.preprocess(sample)
        decoded = decoder.decode(features)
        rahul_out = rahul.interpret(decoded, features)
        decision = spandan.decide(rahul_out, features)
        # final user-facing text
        if rahul_out["text"]:
            logger.log("Output", "USER_TEXT", {"text": rahul_out["text"], "confidence": rahul_out["confidence"], "device_state": decision["device_state"]})
        else:
            logger.log("Output", "SILENT", {"device_state": decision["device_state"]})
    # run the EEG stream and feed into pipeline for runtime_seconds
    stop_at = time.time() + runtime_seconds
    print("=== GRRFP + Rahul.ai integration prototype starting ===")
    # run loop manually: call simulated samples at interval
    interval = 0.6
    while time.time() < stop_at:
        # generate sample (simulate)
        sample = {
            "attention": clamp(random.gauss(0.5, 0.18), 0.0, 1.0),
            "relaxation": clamp(random.gauss(0.5, 0.18), 0.0, 1.0),
            "intent_power": clamp(abs(random.gauss(0.25, 0.25)), 0.0, 1.0),
            "micro_vibration": clamp(abs(random.gauss(0.05, 0.05)), 0.0, 1.0)
        }
        await on_sample_loop(sample)
        await asyncio.sleep(interval)
    print("=== Prototype finished. Final RKC log entries:", len(logger.entries), "===")
    # optional: print last few logs
    for e in logger.entries[-8:]:
        print(e)
# ---------------------------
# Entrypoint
# ---------------------------
if __name__ == "__main__":
    try:
        asyncio.run(main_loop(runtime_seconds=18))
    except KeyboardInterrupt:
        print("Interrupted")
nano grrfp_rahulai.py
cmd
exit
#!/usr/bin/env python3
# GRRFP + Rahul.ai : OpenBCI EEG Integration Prototype
import serial, json, time, asyncio, random, uuid
from typing import Dict, Any
def now(): return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
def clamp(v,a,b): return max(a, min(b, v))
class RKC:
    def __init__(self): self.loglist=[]
    def log(self,src,lvl,data):
        e={"id":str(uuid.uuid4()),"ts":now(),"src":src,"lvl":lvl,"data":data}
        self.loglist.append(e)
        print(f"[RKC] {e['ts']} | {src} | {lvl} | {data}")
class UCG:
    def __init__(self,l): self.l=l
    def check(self,energy):
        act="ALLOW" if energy<0.9 else "THROTTLE"
        self.l.log("UCG","INFO",{"energy":energy,"action":act})
        return act
class OpenBCIReader:
    def __init__(self,port="/dev/ttyUSB0",baud=115200):
        self.port=port; self.baud=baud
        self.ser=serial.Serial(port,baud,timeout=1)
    def read_sample(self):
        line=self.ser.readline().decode(errors="ignore").strip()
        if not line: return None
        try:
            js=json.loads(line)
            ch=js.get("data",[])
            if not ch: return None
            att=clamp(abs(ch[0])/1000.0,0,1)
            relax=clamp(abs(ch[1])/1000.0,0,1)
            inten=clamp(abs(ch[2])/1000.0,0,1)
            return {"attention":att,"relaxation":relax,"intent":inten}
        except Exception: return None
class NRPI:
    def __init__(self,l): self.l=l
    def process(self,s):
        if not s: return None
        ri=(s["attention"]*0.4+s["intent"]*0.6)*(1-abs(s["relaxation"]-0.5))
        self.l.log("NRPI","TRACE",{"sample":s,"ri":ri})
        return {"ri":ri}
class Decoder:
    def __init__(self,l): self.l=l
    def decode(self,f):
        ri=f["ri"]
        if ri>0.7: intent="lights_on"
        elif ri>0.45: intent="greet"
        else: intent="idle"
        txt={"lights_on":"Turning on lights","greet":"Hello there","idle":""}[intent]
        self.l.log("Decoder","INFO",{"ri":ri,"intent":intent})
        return intent,txt
class RahulAI:
    def __init__(self,l): self.l=l
    def interpret(self,intent,text):
        if intent=="greet": text+=" ,friend."
        self.l.log("RahulAI","DEBUG",{"intent":intent,"text":text})
        return text
class Spandan:
    def __init__(self,l,ucg): self.l=l; self.ucg=ucg; self.state={"lights":False}
    def decide(self,intent,text,ri):
        act=self.ucg.check(ri*0.5)
        if intent=="lights_on" and act=="ALLOW": self.state["lights"]=True
        self.l.log("Spandan","INFO",{"intent":intent,"state":self.state})
        return {"text":text,"state":self.state}
async def main():
    log=RKC(); ucg=UCG(log)
    bci=OpenBCIReader("/dev/ttyUSB0")  # adjust port if needed
    nrpi=NRPI(log); dec=Decoder(log); rahul=RahulAI(log); sp=Spandan(log,ucg)
    print("=== GRRFP+Rahul.ai : OpenBCI live ===")
    for _ in range(60):  # ≈30 s runtime
        s=bci.read_sample()
        if not s: continue
        f=nrpi.process(s)
        if not f: continue
        i,t=dec.decode(f)
        msg=rahul.interpret(i,t)
        out=sp.decide(i,msg,f["ri"])
        if msg: log.log("OUTPUT","TEXT",out)
        await asyncio.sleep(0.5)
    print("=== Done ===")
if __name__=="__main__":
    asyncio.run(main())
ত্রুটি সহজ — Python বলছে
NameError: name 'asyncio' is not defined
মানে, তোমার কোডের উপরে import asyncio লেখা হয়নি।
---
✅ ঠিক করা ভার্সন (সংক্ষিপ্ত ও সোজা)
টার্মাক্সে নিচের মতো দাও (একবারে সব কপি–পেস্ট করে, >>> ছাড়া):
import asyncio, serial, json, time, uuid
def now(): return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
def clamp(v,a,b): return max(a, min(b, v))
class RKC:
    def __init__(self): self.loglist=[]
    def log(self,src,lvl,data):
        e={"id":str(uuid.uuid4()),"ts":now(),"src":src,"lvl":lvl,"data":data}
        self.loglist.append(e)
        print(f"[RKC] {e['ts']} | {src} | {lvl} | {data}")
class UCG:
    def __init__(self,l): self.l=l
    def check(self,energy):
        act="ALLOW" if energy<0.9 else "THROTTLE"
        self.l.log("UCG","INFO",{"energy":energy,"action":act})
        return act
class OpenBCIReader:
    def __init__(self,port="/dev/ttyUSB0",baud=115200):
        self.ser=serial.Serial(port,baud,timeout=1)
    def read_sample(self):
        line=self.ser.readline().decode(errors="ignore").strip()
        if not line: return None
        try:
            js=json.loads(line)
            ch=js.get("data",[])
            if not ch: return None
            att=clamp(abs(ch[0])/1000.0,0,1)
            relax=clamp(abs(ch[1])/1000.0,0,1)
            inten=clamp(abs(ch[2])/1000.0,0,1)
            return {"attention":att,"relaxation":relax,"intent":inten}
        except: return None
class NRPI:
    def __init__(self,l): self.l=l
    def process(self,s):
        if not s: return None
        ri=(s["attention"]*0.4+s["intent"]*0.6)*(1-abs(s["relaxation"]-0.5))
        self.l.log("NRPI","TRACE",{"sample":s,"ri":ri})
        return {"ri":ri}
class Decoder:
    def __init__(self,l): self.l=l
    def decode(self,f):
        ri=f["ri"]
        if ri>0.7: intent="lights_on"
        elif ri>0.45: intent="greet"
        else: intent="idle"
        txt={"lights_on":"Turning on lights","greet":"Hello there","idle":""}[intent]
        self.l.log("Decoder","INFO",{"ri":ri,"intent":intent})
        return intent,txt
class RahulAI:
    def __init__(self,l): self.l=l
    def interpret(self,intent,text):
        if intent=="greet": text+=", friend."
        self.l.log("RahulAI","DEBUG",{"intent":intent,"text":text})
        return text
class Spandan:
    def __init__(self,l,ucg): self.l=l; self.ucg=ucg; self.state={"lights":False}
    def decide(self,intent,text,ri):
        act=self.ucg.check(ri*0.5)
        if intent=="lights_on" and act=="ALLOW": self.state["lights"]=True
        self.l.log("Spandan","INFO",{"intent":intent,"state":self.state})
        return {"text":text,"state":self.state}
async def main():
    log=RKC(); ucg=UCG(log)
    bci=OpenBCIReader("/dev/ttyUSB0")
    nrpi=NRPI(log); dec=Decoder(log); rahul=RahulAI(log); sp=Spandan(log,ucg)
    print("=== GRRFP+Rahul.ai : OpenBCI live ===")
    for _ in range(60):
        s=bci.read_sample()
        if not s: continue
        f=nrpi.process(s)
        if not f: continue
        i,t=dec.decode(f)
        msg=rahul.interpret(i,t)
        out=sp.decide(i,msg,f["ri"])
        if msg: log.log("OUTPUT","TEXT",out)
        await asyncio.sleep(0.5)
    print("=== Done ===")
if __name__=="__main__":
    asyncio.run(main())
---
🔹 কারণ ব্যাখ্যা
asyncio Python-এর asynchronous loop controller।
তুমি যখন async def main() ব্যবহার করছো, সেটাকে চালাতে asyncio.run(main()) প্রয়োজন —
আর asyncio লাইব্রেরি ইমপোর্ট না করলে Python সেটি চিনতে পারে না।
---
এখন এই কোডটা .py ফাইলে রেখে চালাও:
python3 grrfp_rahulai_openbci.py
সব কাজ করলে আউটপুটে [RKC] ... লগগুলো আবার দেখতে পাবে।
চাও কি আমি এখন এই সিস্টেমে lights_on intent হলে Wi-Fi দিয়ে তোমার ESP8266/ESP32-এর রিলে অন করে দিই (IoT কমান্ড আউটপুট)?
exit()
#!/usr/bin/env python3
# GRRFP + Rahul.ai Unified Cognitive Pipeline (Termux Safe Version)
import asyncio, serial, json, time, uuid, requests, socket, os
from subprocess import call
# ===== Utility =====
def now(): 
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
def clamp(v, a, b): 
    return max(a, min(b, v))
def speak(txt):
    try:
        call(["termux-tts-speak", txt])
    except Exception:
        print("[WARN] TTS unavailable")
# ===== RKC Logger =====
class RKC:
    def __init__(self): 
        self.logs = []
    def log(self, src, lvl, data):
        entry = {
            "id": str(uuid.uuid4()),
            "time": now(),
            "src": src,
            "lvl": lvl,
            "data": data
        }
        self.logs.append(entry)
        print(f"[RKC] {entry['time']} | {src} | {lvl} | {data}")
# ===== UCG (Universal Circulation Governor) =====
class UCG:
    def __init__(self, logger): 
        self.l = logger
    def check(self, energy):
        action = "ALLOW" if energy < 0.9 else "THROTTLE"
        self.l.log("UCG", "INFO", {"energy": energy, "action": action})
        return action
# ===== OpenBCI Reader (Serial + TCP Fallback) =====
class OpenBCIReader:
    def __init__(self, logger, port="/dev/ttyUSB0", baud=115200, host=None, port_tcp=9000):
        self.l = logger
        self.serial = None
        self.sock = None
        try:
            if host:
                self.sock = socket.socket()
                self.sock.connect((host, port_tcp))
                self.l.log("BRAINLINK", "INFO", f"Connected via TCP {host}:{port_tcp}")
            else:
                self.serial = serial.Serial(port, baud, timeout=1)
                self.l.log("BRAINLINK", "INFO", f"Connected serial {port}")
        except Exception as e:
            self.l.log("BRAINLINK", "ERROR", f"Connection failed: {e}")
    def read_sample(self):
        try:
            if self.serial:
                line = self.serial.readline().decode(errors="ignore").strip()
            elif self.sock:
                line = self.sock.recv(1024).decode(errors="ignore").strip()
            else:
                return None
            if not line:
                return None
            js = json.loads(line)
            ch = js.get("data", [])
            if not ch:
                return None
            att = clamp(abs(ch[0]) / 1000.0, 0, 1)
            relax = clamp(abs(ch[1]) / 1000.0, 0, 1)
            inten = clamp(abs(ch[2]) / 1000.0, 0, 1)
            return {"attention": att, "relaxation": relax, "intent": inten}
        except Exception:
            return None
# ===== NRPI =====
class NRPI:
    def __init__(self, logger): 
        self.l = logger
    def process(self, sample):
        if not sample:
            return None
        ri = (sample["attention"] * 0.4 + sample["intent"] * 0.6) * (1 - abs(sample["relaxation"] - 0.5))
        self.l.log("NRPI", "TRACE", {"sample": sample, "ri": ri})
        return {"ri": ri}
# ===== Decoder =====
class Decoder:
    def __init__(self, logger): 
        self.l = logger
    def decode(self, frame):
        ri = frame["ri"]
        if ri > 0.7:
            intent = "lights_on"
        elif ri > 0.45:
            intent = "greet"
        else:
            intent = "idle"
        text = {"lights_on": "Turning on lights", "greet": "Hello there", "idle": ""}[intent]
        self.l.log("Decoder", "INFO", {"ri": ri, "intent": intent})
        return intent, text
# ===== RahulAI =====
class RahulAI:
    def __init__(self, logger): 
        self.l = logger
    def interpret(self, intent, text):
        if intent == "greet":
            text += ", friend."
        self.l.log("RahulAI", "DEBUG", {"intent": intent, "text": text})
        return text
# ===== Spandan (IoT + Output Layer) =====
class Spandan:
    def __init__(self, logger, ucg, relay_url=None):
        self.l = logger
        self.ucg = ucg
        self.state = {"lights": False}
        self.relay_url = relay_url
    def decide(self, intent, text, ri):
        act = self.ucg.check(ri * 0.5)
        if intent == "lights_on" and act == "ALLOW":
            self.state["lights"] = True
            if self.relay_url:
                try:
                    requests.get(self.relay_url, timeout=2)
                    self.l.log("IoT", "INFO", {"url": self.relay_url, "result": "triggered"})
                except Exception as e:
                    self.l.log("IoT", "ERROR", str(e))
        if intent == "idle" and self.state["lights"]:
            self.state["lights"] = False
            self.l.log("IoT", "INFO", "Relay OFF")
        self.l.log("Spandan", "INFO", {"intent": intent, "state": self.state})
        return {"text": text, "state": self.state}
# ===== Main Brain Loop =====
async def main():
    log = RKC()
    ucg = UCG(log)
    bci = None
    try:
        bci = OpenBCIReader(log, "/dev/ttyUSB0")
    except Exception:
        bci = OpenBCIReader(log, None, host="192.168.0.101", port_tcp=9000)
    nrpi = NRPI(log)
    dec = Decoder(log)
    rahul = RahulAI(log)
    relay = "http://192.168.0.105/relay_on"
    sp = Spandan(log, ucg, relay)
    print("=== GRRFP + Rahul.ai Unified : Live Mode ===")
    for _ in range(60):  # Run for ~30s
        s = bci.read_sample()
        if not s:
            continue
        f = nrpi.process(s)
        if not f:
            continue
        intent, text = dec.decode(f)
        msg = rahul.interpret(intent, text)
        out = sp.decide(intent, msg, f["ri"])
        if msg:
            speak(msg)
            log.log("OUTPUT", "TEXT", out)
        await asyncio.sleep(0.5)
    print("=== Done ===")
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("Interrupted.")
exit
pkg update -y
pkg install python termux-api -y
pip install pyserial requests
nano grrfp_rahulai_full.py
# Paste all code above, save and exit (CTRL + O, ENTER, CTRL + X)
python3 grrfp_rahulai_full.py
exit
try:
    bci = OpenBCIReader(log,"/dev/ttyUSB0")
except:
    bci = OpenBCIReader(log,None,host="192.168.0.101",port_tcp=9000)
# --- Simulation mode if no BCI hardware ---
class FakeBCI:
    def read_sample(self):
        import random
        return {
            "attention": random.random(),
            "relaxation": random.random(),
            "intent": random.random()
        }
bci = FakeBCI()
You’re correct — that error is because no physical OpenBCI device or serial port exists on your phone (/dev/ttyUSB0 can’t be found).
We fix this permanently by adding a software simulation fallback — so the GRRFP + Rahul.ai system will run live even without hardware.
---
✅ Final Fixed Version (with FakeBCI fallback)
Replace your entire grrfp_rahulai_full.py file with this code:
#!/usr/bin/env python3
# GRRFP + Rahul.ai Unified Cognitive Pipeline (Hardware + Sim Mode)
import asyncio, serial, json, time, uuid, requests, socket, random
from subprocess import call
def now(): return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
def clamp(v, a, b): return max(a, min(b, v))
def speak(txt): 
    try: call(["termux-tts-speak", txt])
    except: print("[WARN] TTS unavailable")
class RKC:
    def __init__(self): self.logs = []
    def log(self, src, lvl, data):
        e = {"id": str(uuid.uuid4()), "time": now(), "src": src, "lvl": lvl, "data": data}
        self.logs.append(e)
        print(f"[RKC] {e['time']} | {src} | {lvl} | {data}")
class UCG:
    def __init__(self, l): self.l = l
    def check(self, e):
        a = "ALLOW" if e < 0.9 else "THROTTLE"
        self.l.log("UCG", "INFO", {"energy": e, "action": a})
        return a
class OpenBCIReader:
    def __init__(self, l, port="/dev/ttyUSB0", baud=115200, host=None, port_tcp=9000):
        self.l = l; self.serial = None; self.sock = None
        try:
            if host:
                self.sock = socket.socket(); self.sock.connect((host, port_tcp))
                self.l.log("BRAINLINK", "INFO", f"TCP {host}:{port_tcp}")
            else:
                self.serial = serial.Serial(port, baud, timeout=1)
                self.l.log("BRAINLINK", "INFO", f"Serial {port}")
        except Exception as e:
            self.l.log("BRAINLINK", "ERROR", f"{e}")
            raise e
    def read_sample(self):
        try:
            if self.serial:
                line = self.serial.readline().decode(errors="ignore").strip()
            elif self.sock:
                line = self.sock.recv(1024).decode(errors="ignore").strip()
            else:
                return None
            if not line: return None
            js = json.loads(line)
            ch = js.get("data", [])
            if not ch: return None
            a = clamp(abs(ch[0])/1000, 0, 1)
            r = clamp(abs(ch[1])/1000, 0, 1)
            i = clamp(abs(ch[2])/1000, 0, 1)
            return {"attention": a, "relaxation": r, "intent": i}
        except: return None
# === Simulation fallback ===
class FakeBCI:
    def __init__(self, l): self.l = l
    def read_sample(self):
        s = {
            "attention": random.random(),
            "relaxation": random.random(),
            "intent": random.random()
        }
        self.l.log("FakeBCI", "SIM", s)
        return s
class NRPI:
    def __init__(self, l): self.l = l
    def process(self, s):
        if not s: return None
        ri = (s["attention"]*0.4 + s["intent"]*0.6) * (1 - abs(s["relaxation"]-0.5))
        self.l.log("NRPI", "TRACE", {"sample": s, "ri": ri})
        return {"ri": ri}
class Decoder:
    def __init__(self, l): self.l = l
    def decode(self, f):
        ri = f["ri"]
        if ri > 0.7: intent = "lights_on"
        elif ri > 0.45: intent = "greet"
        else: intent = "idle"
        txt = {"lights_on":"Turning on lights","greet":"Hello there","idle":""}[intent]
        self.l.log("Decoder","INFO",{"ri":ri,"intent":intent})
        return intent, txt
class RahulAI:
    def __init__(self, l): self.l = l
    def interpret(self, i, t):
        if i == "greet": t += ", friend."
        self.l.log("RahulAI","DEBUG",{"intent":i,"text":t})
        return t
class Spandan:
    def __init__(self, l, ucg, relay=None):
        self.l = l; self.ucg = ucg; self.state = {"lights":False}; self.relay = relay
    def decide(self, i, t, ri):
        a = self.ucg.check(ri*0.5)
        if i == "lights_on" and a == "ALLOW":
            self.state["lights"] = True
            if self.relay:
                try:
                    requests.get(self.relay, timeout=2)
                    self.l.log("IoT","INFO",{"url":self.relay,"result":"triggered"})
                except Exception as e:
                    self.l.log("IoT","ERROR",str(e))
        if i == "idle" and self.state["lights"]:
            self.state["lights"] = False
            self.l.log("IoT","INFO","Relay OFF")
        self.l.log("Spandan","INFO",{"intent":i,"state":self.state})
        return {"text":t,"state":self.state}
async def main():
    log = RKC(); ucg = UCG(log)
    try: bci = OpenBCIReader(log,"/dev/ttyUSB0")
    except: 
        log.log("SYSTEM","WARN","No hardware found — using FakeBCI simulation mode")
        bci = FakeBCI(log)
    nrpi = NRPI(log); dec = Decoder(log); rahul = RahulAI(log)
    sp = Spandan(log, ucg, "http://192.168.0.105/relay_on")
    print("=== GRRFP + Rahul.ai Unified : Live Mode ===")
    for _ in range(30):
        s = bci.read_sample()
        if not s: continue
        f = nrpi.process(s)
        if not f: continue
        i, t = dec.decode(f)
        msg = rahul.interpret(i, t)
        out = sp.decide(i, msg, f["ri"])
        if msg:
            speak(msg)
            log.log("OUTPUT","TEXT",out)
        await asyncio.sleep(0.5)
    print("=== Done ===")
if __name__ == "__main__":
    try: asyncio.run(main())
    except KeyboardInterrupt: print("Interrupted.")
---
✅ Run it again
python3 grrfp_rahulai_full.py
---
🧠 Result
If your OpenBCI board or /dev/ttyUSB0 is connected, it will read real data.
If not, it automatically switches to FakeBCI simulation (random EEG-like values).
You’ll see continuous [RKC] logs for all modules.
Voice output (termux-tts-speak) says things like “Hello there, friend” or “Turning on lights.”
---
Do you want me to add real CSV logging + auto boot at Termux startup next?
# grrf_brahma.py
# Python representation of the integrated GRRF / SpandanOS / GBRS / BRAHMA system.
# Usage:
#   from grrf_brahma import MASTER_SYSTEM
#   print(MASTER_SYSTEM.to_json())
#   print(MASTER_SYSTEM.to_patent_spec())
#   print(MASTER_SYSTEM.to_dot())
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Any
import json
import textwrap
import datetime
@dataclass
class Module:
    id: str
    name: str
    summary: str
    functions: List[str] = field(default_factory=list)
    interfaces: List[str] = field(default_factory=list)
    risk_notes: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    def to_dict(self):
        return asdict(self)
@dataclass
class SystemNode:
    id: str
    name: str
    modules: List[Module] = field(default_factory=list)
    children: List["SystemNode"] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    def add_module(self, m: Module):
        self.modules.append(m)
    def add_child(self, node: "SystemNode"):
        self.children.append(node)
    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "modules": [m.to_dict() for m in self.modules],
            "children": [c.to_dict() for c in self.children],
            "metadata": self.metadata,
        }
@dataclass
class IntegratedSystem:
    root: SystemNode
    created_at: str = field(default_factory=lambda: datetime.datetime.utcnow().isoformat() + "Z")
    version: str = "1.0"
    def to_json(self, indent=2) -> str:
        payload = {
            "version": self.version,
            "created_at": self.created_at,
            "root": self.root.to_dict()
        }
        return json.dumps(payload, indent=indent)
    def to_patent_spec(self) -> str:
        """
        Produce a concise patent-style specification text (Form-2 style condensed).
        """
        lines = []
        lines.append(f"Title: Integrated Impulse–Vibration Framework (GRRF–SpandanOS–GBRS–BRAHMA) — v{self.version}")
        lines.append("Inventor: Shri Prasenjit Ghosh")
        lines.append("")
        lines.append("Field of the Invention:")
        lines.append("A unified resonance-based system integrating robotics, energy systems, consciousness-inspired computing, and biomedical regeneration.")
        lines.append("")
        lines.append("Background:")
        lines.append("Existing solutions separate energy, robotics, AI, and regenerative medicine. This invention synchronizes them by a resonance-coded control protocol.")
        lines.append("")
        lines.append("Summary:")
        lines.append("The system comprises:")
        def walk(node: SystemNode, prefix=""):
            lines.append(f"{prefix}{node.name}:")
            for m in node.modules:
                lines.append(f"{prefix}  - {m.name}: {m.summary}")
            for c in node.children:
                walk(c, prefix + "  ")
        walk(self.root)
        lines.append("")
        lines.append("Representative claims (illustrative):")
        lines.append("1. An integrated system comprising: a vibrational computing core; a consciousness-inspired OS interfaced via wearable hardware; an energy subsystem including a NuCell Reactor; and a biomedical regeneration subsystem comprising PBBG, TLCSS, SRN and NTR, all synchronized by a resonance-coded control protocol.")
        lines.append("2. The system of claim 1 wherein the NuCell Reactor provides battery-free vibrational energy for wearable and robotic systems.")
        lines.append("3. The system of claim 1 wherein GBRS subsystems operate in a sequence orchestrated by resonance signals.")
        lines.append("")
        lines.append("Industrial Applicability:")
        lines.append("Healthcare, robotics, clean energy, propulsion, and civilizational operating systems.")
        return "\n".join(lines)
    def to_dot(self) -> str:
        """
        Export a DOT graph (Graphviz) describing nodes and connections.
        """
        lines = ["digraph GRRF_BRAHMA {", '  rankdir=LR;', '  node [shape=box, style=rounded];']
        id_map = {}
        def register(node: SystemNode):
            nid = node.id.replace('-', '_')
            id_map[node.id] = nid
            label = node.name.replace('"', '\\"')
            lines.append(f'  {nid} [label="{label}"];')
            # modules as subnodes
            for m in node.modules:
                mid = f"{nid}_{m.id}".replace('-', '_')
                mlabel = f"{m.name}\\n({', '.join([f[:30] for f in m.functions])})"
                lines.append(f'  {mid} [label="{mlabel}", shape=note];')
                lines.append(f'  {nid} -> {mid} [style=dashed];')
            for c in node.children:
                register(c)
                lines.append(f'  {nid} -> {id_map[c.id]};')
        register(self.root)
        lines.append("}")
        return "\n".join(lines)
# --------------------------
# Build the integrated model
# --------------------------
# Core GRRF node
grrf = SystemNode(id="node-grrf", name="GRRF (Ghosh Relativistic Robotics Framework)")
grrf.add_module(Module(
    id="m-ivf",
    name="Impulse–Vibration Framework (IvF)",
    summary="Models breath, emotion and motion as impulse-vibration computing units.",
    functions=["encode_impulse", "map_resonance", "vibrational_memory_store"],
    interfaces=["SpandanOS", "IVIS_CORE"],
    risk_notes=["Requires measurable sensor fidelity; experimental theory"]
))
grrf.add_module(Module(
    id="m-vml",
    name="Vibrational Memory Layer (VML)",
    summary="Stores non-verbal and emotional memory as resonance patterns.",
    functions=["store_echo", "trigger_reconstruction"],
    interfaces=["Rahul.ai", "DreamVault"]
))
# SpandanOS node
spand = SystemNode(id="node-spandan", name="SpandanOS (Consciousness OS)")
spand.add_module(Module(
    id="m-spandcore",
    name="SpandCore Wearable",
    summary="Battery-less piezo-powered wearable capturing breath, pulse and micro-impulses.",
    functions=["sense_breath", "sense_pulse", "harvest_vibration"],
    interfaces=["NuCell", "IVIS_CORE"],
    risk_notes=["Hardware miniaturization & reliability"]
))
spand.add_module(Module(
    id="m-ivis",
    name="IVIS_CORE",
    summary="Converts breath/emotion inputs into machine commands.",
    functions=["map_emotion_to_action", "low_latency_control"],
    interfaces=["GRRF", "ARJ Bot"]
))
# GBRS node
gbrs = SystemNode(id="node-gbrs", name="GBRS (Biomedical Regeneration System)")
gbrs.add_module(Module(
    id="m-pbbg",
    name="PBBG (Portable BioSynth Blood Generator)",
    summary="Microfluidic cartridge producing programmable artificial blood.",
    functions=["cell_differentiation", "o2_affinity_tune", "biosensor_feedback"],
    risk_notes=["Regulatory; immunogenicity"]
))
gbrs.add_module(Module(
    id="m-tlcss",
    name="TLCSS (Tumor-Localized CRISPR Suicide Switch)",
    summary="Tumor microenvironment-activated CRISPR suicide payload delivered by targeted nanoparticles.",
    functions=["tumor_detection", "conditional_crispr_activation"],
    risk_notes=["off-target edits; delivery efficiency"]
))
gbrs.add_module(Module(
    id="m-srn",
    name="SRN (Synaptic Rebuilder Nanovesicles)",
    summary="BBB-crossing vesicles for synaptic repair.",
    functions=["bbb_crossing", "synaptogenic_release"],
    risk_notes=["variable uptake; excitotoxicity"]
))
gbrs.add_module(Module(
    id="m-ntr",
    name="NTR (Nano Tissue Regenerator)",
    summary="Injectable programmable scaffold with staged growth factor release.",
    functions=["scaffold_assembly", "staged_release", "photonic_control"],
    risk_notes=["fibrosis; degradation_mismatch"]
))
# Energy & Propulsion node
energy = SystemNode(id="node-energy", name="Energy & Propulsion")
energy.add_module(Module(
    id="m-nucell",
    name="NuCell Reactor",
    summary="Battery-free vibrational energy core for wearables and robotics.",
    functions=["convert_vibration_to_power", "node_energy_map"],
    interfaces=["SpandCore", "SpandSuit"],
    risk_notes=["power_density limits; experimental"]
))
energy.add_module(Module(
    id="m-thorium",
    name="Thorium Fusion Reactor (hybrid)",
    summary="Thorium-based compact reactor design for mobile high-density energy.",
    functions=["thorium_reactor_control", "vibrational_containment"],
    risk_notes=["nuclear_regulation; engineering complexity"]
))
energy.add_module(Module(
    id="m-zmd",
    name="ZMD (Zero Mass Drive)",
    summary="Propulsion concept based on local mass modulation via impulse resonance.",
    functions=["mass_modulation", "impulse_actuation"],
    risk_notes=["highly speculative; physics validation required"]
))
# BRAHMA / Civilizational node
brahma = SystemNode(id="node-brahma", name="BRAHMA Framework (Resonant OS & Governance)")
brahma.add_module(Module(
    id="m-recos",
    name="ReCOS Kernel",
    summary="Hybrid resonance OS kernel for distributed memory & coordination (ReCOS).",
    functions=["rag_retrieval", "resonant_scheduler", "audit_logs"],
    interfaces=["SyRCMNet", "UCG"]
))
brahma.add_module(Module(
    id="m-ucg",
    name="UCG (Universal Circulation Governor)",
    summary="Governance & circulation regulator module for systemic balance.",
    functions=["circulation_monitor", "policy_enforcer"],
    risk_notes=["societal, legal, ethical constraints"]
))
brahma.add_child(grrf)
brahma.add_child(spand)
brahma.add_child(gbrs)
brahma.add_child(energy)
# Root master system
root = SystemNode(id="node-brahma-root", name="MASTER: BRAHMA / GRRF Integrated System")
root.add_child(brahma)
MASTER_SYSTEM = IntegratedSystem(root=root)
# --------------------------
# Optional helper execution
# --------------------------
if __name__ == "__main__":
    # quick demo if module is executed directly
    print("=== JSON Export ===")
    print(MASTER_SYSTEM.to_json())
    print("\n=== Patent Spec (condensed) ===")
    print(MASTER_SYSTEM.to_patent_spec())
    print("\n=== DOT Graph ===")
    print(MASTER_SYSTEM.to_dot())
clear
cls
pkg update -y
pkg install python -y
pip install pyqt5  # GUI won't show, but logic works
pkg install proot-distro -y
proot-distro install ubuntu
proot-distro login ubuntu
clear
exit
exit()
# ghosh_notepad.py
# GHOSH ROBOTICS Notepad (Kivy version)
# Works inside Termux → Ubuntu → Buildozer for APK build
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.textinput import TextInput
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.core.window import Window
from kivy.utils import platform
from kivy.uix.filechooser import FileChooserListView
from kivy.uix.popup import Popup
import os
class NotepadLayout(BoxLayout):
    def __init__(self, **kwargs):
        super().__init__(orientation="vertical", **kwargs)
        Window.size = (600, 400)
        self.add_widget(Label(text="GHOSH ROBOTICS Notepad", size_hint_y=None, height=40))
        self.text = TextInput(multiline=True, font_size=16)
        self.add_widget(self.text)
        btns = BoxLayout(size_hint_y=None, height=50)
        save_btn = Button(text="Save As")
        save_btn.bind(on_release=self.save_as)
        clear_btn = Button(text="Clear")
        clear_btn.bind(on_release=lambda x: self.text.text = "")
        btns.add_widget(save_btn)
        btns.add_widget(clear_btn)
        self.add_widget(btns)
    def save_as(self, instance):
        chooser = FileChooserListView(path=os.getcwd(), filters=["*.txt"])
        popup = Popup(title="Select save location", content=chooser, size_hint=(0.9, 0.9))
        def save_selected(obj, selection):
            if selection:
                with open(selection[0], "w", encoding="utf-8") as f:
                    f.write(self.text.text)
                popup.dismiss()
        chooser.bind(on_submit=save_selected)
        popup.open()
class GHOSHNotepadApp(App):
    def build(self):
        self.title = "GHOSH ROBOTICS"
        return NotepadLayout()
if __name__ == "__main__":
    GHOSHNotepadApp().run()
exit()
